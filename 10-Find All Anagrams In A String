//Bruteforce Approach

class Solution {
    /**
     * Definition of Anagram:
     * - Two strings are anagrams if they contain the same characters
     *   with the same frequencies, regardless of order.
     * Example:
     * pattern = "abc"
     * valid anagrams: "abc", "bca", "cab"
     */
    public List<Integer> findAnagrams(String text, String pattern) {
        List<Integer> startIndices = new ArrayList<>();

        // Frequency array to count characters in the current substring
        int[] freqArr = new int[26];

        // Generate every possible substring of length equal to the pattern.
        for (int start = 0; start < text.length(); start++) {
            // Expand substring from the current start index
            for (int end = start; end < text.length(); end++) {
                // Add current character to frequency array
                freqArr[text.charAt(end) - 'a']++;

                int substringLength = end - start + 1;

                // Process only substrings of exact pattern length
                if (substringLength == pattern.length()) {
                    // Check if current substring is an anagram
                    if (isAnagram(pattern, freqArr)) {
                        startIndices.add(start);
                    }

                    // Stop expanding this window and move to next start
                    break;
                }
            }

            // Reset frequency array for the next starting index
            Arrays.fill(freqArr, 0);
        }

        return startIndices;
    }

    /**
    * Checks whether the current window is an anagram of the pattern.
    *
    * Logic:
    * - For each character in the pattern:
    *     - If its frequency is zero in the window, it means either:
    *         1) The character is not present in the current window at all, OR
    *         2) The pattern contains this character more times than the window does.
    *       In both cases, the window cannot be an anagram.
    *     - Otherwise, decrement the frequency to account for one matched occurrence.
    * - If all characters of the pattern are successfully matched,
    *   the current window is an anagram.
    */
    private boolean isAnagram(String pattern, int[] freqArr) {
        for (int i = 0; i < pattern.length(); i++) {
            int idx = pattern.charAt(i) - 'a';

            if (freqArr[idx] == 0) {
                return false;
            }

            freqArr[idx]--;
        }

        return true;
    }
}


//Good Approach

class Solution {
    /**
     * ------------------------------------------------------------
     * Why this is a FIXED-SIZE sliding window problem:
     * ------------------------------------------------------------
     * - Any anagram of `pattern` must have EXACTLY the same length
     *   as the pattern.
     * - Therefore, the window size is fixed and equal to
     *   pattern.length().
     * - We slide this fixed-size window over the text and check
     *   whether the current window forms an anagram of the pattern.
     */
    public List<Integer> findAnagrams(String text, String pattern) {
        // If pattern is longer than text, no anagram is possible
        if (pattern.length() > text.length()) {
            return Collections.emptyList();
        }

        int windowStart = 0;
        int windowEnd = 0;

        // Fixed window size equals pattern length
        int windowSize = pattern.length();

        // Stores starting indices of valid anagrams
        List<Integer> startIndices = new ArrayList<>();

        /*
         * Frequency array for the current window.
         * freqArr[i] represents how many times character (char)('a' + i)
         * appears in the current sliding window.
         */
        int[] freqArr = new int[26];

        /*
         * Build the first window of size = pattern.length()
         * Count frequencies of characters in the initial window.
         */
        while (windowEnd < windowSize) {
            freqArr[text.charAt(windowEnd) - 'a']++;
            windowEnd++;
        }

        // Check if the first window is an anagram of the pattern
        if (isAnagram(pattern, freqArr)) {
            startIndices.add(windowStart);
        }

        /*
         * Slide the window across the text:
         * - Remove the character leaving the window (windowStart)
         * - Add the character entering the window (windowEnd)
         * - After each slide, check if the window is an anagram
         */
        while (windowEnd < text.length()) {
            // Remove outgoing character (left boundary of window)
            freqArr[text.charAt(windowStart) - 'a']--;
            windowStart++;

            // Add incoming character (right boundary of window)
            freqArr[text.charAt(windowEnd) - 'a']++;

            // Check if current window forms an anagram
            if (isAnagram(pattern, freqArr)) {
                startIndices.add(windowStart);
            }

            // Move the right boundary forward
            windowEnd++;
        }

        return startIndices;
    }

    /**
     * Checks whether the current window is an anagram of the pattern.
     *
     * Logic:
     * - Clone the window frequency array to avoid modifying the original state.
     * - For each character in the pattern:
     *     - If its frequency is zero in the window, it means either:
     *         1) The character is not present in the current window at all, OR
     *         2) The pattern contains this character more times than the window does.
     *       In both cases, the window cannot be an anagram.
     *     - Otherwise, decrement the frequency to account for one matched occurrence.
     * - If all characters of the pattern are successfully matched,
     *   the current window is an anagram.
     */
    private boolean isAnagram(String pattern, int[] freqArr) {
        freqArr = freqArr.clone();

        for (int i = 0; i < pattern.length(); i++) {
            int idx = pattern.charAt(i) - 'a';

            if (freqArr[idx] == 0) {
                return false;
            }
            freqArr[idx]--;
        }

        return true;
    }
}


//Better Approach

class Solution {
    public List<Integer> findAnagrams(String text, String pattern) {
        // If pattern is longer than text, anagram is impossible
        if (pattern.length() > text.length()) {
            return Collections.emptyList();
        }

        List<Integer> startIndices = new ArrayList<>();

        int windowStart = 0;
        int windowEnd = 0;
        int windowSize = pattern.length();

        /*
         * ------------------------------------------------------------
         * What does patternFreqMap represent?
         * ------------------------------------------------------------
         * patternFreqMap keeps track of how many MORE times
         * each character is still REQUIRED in the current window
         * to form a valid anagram.
         *
         * Initially:
         *   pattern = "aab"
         *   map = {a=2, b=1}
         *
         * Interpretation:
         * - a is required 2 more times
         * - b is required 1 more time
         */
        Map<Character, Integer> patternFreqMap = new HashMap<>();

        // Build frequency map from the pattern
        for (int i = 0; i < pattern.length(); i++) {
            char ch = pattern.charAt(i);
            patternFreqMap.put(ch, patternFreqMap.getOrDefault(ch, 0) + 1);
        }

        /*
         * Build the first window of size = pattern.length()
         * Reduce frequency when pattern characters appear in window.
         */
        while (windowEnd < windowSize) {
            char ch = text.charAt(windowEnd++);

            if (patternFreqMap.containsKey(ch)) {
                patternFreqMap.put(ch, patternFreqMap.get(ch) - 1);
            }
        }

        // If all frequencies are zero â†’ first window is an anagram
        if (isAnagram(patternFreqMap)) {
            startIndices.add(windowStart);
        }

        while (windowEnd < text.length()) {
            /*
             * ------------------------------------------------------------
             * OUTGOING CHARACTER (leaving the window)
             * ------------------------------------------------------------
             * When a character leaves the window:
             * - If it belongs to the pattern, we INCREASE its count.
             *
             * Why?
             * - That character is no longer contributing to the current window.
             * - We now REQUIRE one more occurrence of it again to form an anagram.
             */
            char outgoing = text.charAt(windowStart);
            if (patternFreqMap.containsKey(outgoing)) {
                patternFreqMap.put(outgoing, patternFreqMap.get(outgoing) + 1);
            }

            windowStart++;

            /*
             * ------------------------------------------------------------
             * INCOMING CHARACTER (entering the window)
             * ------------------------------------------------------------
             * When a character enters the window:
             * - If it belongs to the pattern, we DECREASE its count.
             *
             * Why?
             * - This character helps satisfy the anagram requirement.
             */
            char incoming = text.charAt(windowEnd);
            if (patternFreqMap.containsKey(incoming)) {
                patternFreqMap.put(incoming, patternFreqMap.get(incoming) - 1);
            }

            if (isAnagram(patternFreqMap)) {
                startIndices.add(windowStart);
            }

            windowEnd++;
        }

        return startIndices;
    }

    /**
     * Checks whether the current window is an anagram.
     *
     * An anagram exists when:
     * - All character requirements are fully satisfied.
     * - i.e., all values in the frequency map are exactly zero.
     *
     * NOTE:
     * - Negative values means the window has MORE occurrences of this
     *   character than required by the pattern.
     * - Any positive value means some character is still missing.
     */
    private boolean isAnagram(Map<Character, Integer> patternFreqMap) {
        for (int count : patternFreqMap.values()) {
            if (count != 0) {
                return false;
            }
        }
        return true;
    }
}


//Optimal Approach

class Solution {
    public List<Integer> findAnagrams(String text, String pattern) {
        if (pattern.length() > text.length()) {
            return Collections.emptyList();
        }

        List<Integer> startIndices = new ArrayList<>();

        /*
         * patternFreqArr:
         * Stores frequency of each character in the pattern.
         *
         * windowFreqArr:
         * Stores frequency of each character in the current window of text.
         */
        int[] patternFreqArr = new int[26];
        int[] windowFreqArr = new int[26];

        // Build frequency array for the pattern
        for (int i = 0; i < pattern.length(); i++) {
            patternFreqArr[pattern.charAt(i) - 'a']++;
        }

        int windowStart = 0;
        int windowEnd = 0;
        int windowSize = pattern.length();

        /*
         * Build the FIRST window of size = pattern length.
         * Count frequencies of characters in this initial window.
         */
        while (windowEnd < windowSize) {
            windowFreqArr[text.charAt(windowEnd) - 'a']++;
            windowEnd++;
        }

        // If first window's frequency matches the pattern, first window is an anagram
        if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
            startIndices.add(windowStart);
        }

        while (windowEnd < text.length()) {
            // Remove outgoing character
            windowFreqArr[text.charAt(windowStart++) - 'a']--;

            // Add incoming character
            windowFreqArr[text.charAt(windowEnd++) - 'a']++;

            // Check if current window is a anagram of the pattern
            if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
                startIndices.add(windowStart);
            }
        }

        return startIndices;
    }

    /**
     * Compares two frequency arrays.
     *
     * Logic:
     * - If frequencies of ALL characters ('a' to 'z') are equal,
     *   then the two strings are anagrams of each other.
     *
     */
    private boolean areFrequenciesEqual(int[] freqArr1, int[] freqArr2) {
        for (int i = 0; i < 26; i++) {
            if (freqArr1[i] != freqArr2[i]) {
                return false;
            }
        }

        return true;
    }
}
