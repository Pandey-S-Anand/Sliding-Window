//Bruteforce Approach

class Solution {
    /**
     * Brute-force approach to check whether str2
     * contains any permutation of str1.
     *
     * ------------------------------------------------------------
     * What does "permutation" mean here?
     * ------------------------------------------------------------
     * - A permutation of str1 is any reordering of its characters.
     * - Example:
     *     str1 = "ab"
     *     Valid permutations: "ab", "ba"
     *
     * If any substring of str2 of length = str1.length()
     * is a permutation of str1, we return true.
     *
     */
    public boolean checkInclusion(String str1, String str2) {
        // If str1 is longer than str2, it is impossible for any substring of str2 to be a permutation of str1.
        if (str1.length() > str2.length()) {
            return false;
        }
        
        // Frequency array for the current substring window
        int[] freqArr = new int[26];

        // Generate all possible substrings of str2
        for (int start = 0; start < str2.length(); start++) {
            // Expand substring starting at index 'start'
            for (int end = start; end < str2.length(); end++) {
                // Add current character to frequency array
                freqArr[str2.charAt(end) - 'a']++;

                int substringLength = end - start + 1;

                // Process only substrings of exact length = str1.length()
                if (substringLength == str1.length()) {
                    // Check if current substring is a permutation of str1
                    if (containsPermutation(str1, freqArr)) {
                        return true;
                    }

                    // Stop expanding this window and move to next start
                    break;
                }
            }

            // Reset frequency array for the next starting index
            Arrays.fill(freqArr, 0);
        }

        return false;
    }

    /**
     * Checks whether the current window can form
     * a permutation of str1.
     *
     * Logic:
     * - For each character in str1:
     *     - If its frequency in the window is zero,
     *       it means:
     *         1) The character does not exist in the window, OR
     *         2) The window does not have enough occurrences.
     *       Hence, it cannot be a permutation.
     *     - Otherwise, decrement its frequency to mark usage.
     *
     * If all characters of str1 are successfully matched,
     * the window contains a valid permutation.
     */
    private boolean containsPermutation(String str, int[] freqArr) {
        for (int i = 0; i < str.length(); i++) {
            int idx = str.charAt(i) - 'a';

            if (freqArr[idx] == 0) {
                return false;
            }

            freqArr[idx]--;
        }

        return true;
    }
}



//Good Approach

class Solution {
    /**
     * Checks whether text contains any permutation of pattern.
     *
     * ------------------------------------------------------------
     * Key Insight:
     * ------------------------------------------------------------
     * - A permutation of a string is simply an anagram of that string.
     * - Therefore:
     *     "Does text contain a permutation of pattern?"
     *   becomes:
     *     "Does text contain any substring which is an anagram of pattern?"
     *
     * ------------------------------------------------------------
     * Why this is a FIXED-SIZE Sliding Window problem:
     * ------------------------------------------------------------
     * - Any permutation (anagram) of pattern must have the same length
     *   as pattern.
     * - Hence, we slide a window of fixed size = pattern.length()
     *   across text and check each window.
     */
    public boolean checkInclusion(String pattern, String text) {
        // If pattern is longer than text, permutation is impossible
        if (pattern.length() > text.length()) {
            return false;
        }

        int windowStart = 0;
        int windowEnd = 0;

        // Fixed window size equals length of pattern
        int windowSize = pattern.length();

        /*
        * Frequency array for the current window.
        * freqArr[i] represents how many times character (char)('a' + i)
        * appears in the current sliding window.
        */
        int[] freqArr = new int[26];

        /*
         * Build the first window of size = pattern.length()
         * Count frequencies of characters in the initial window.
         */
        while (windowEnd < windowSize) {
            freqArr[text.charAt(windowEnd) - 'a']++;
            windowEnd++;
        }

        // Check if the first window is an anagram of pattern
        if (isAnagram(pattern, freqArr)) {
            return true;
        }

        /*
         * Slide the window across text:
         * - Remove the character leaving the window (left boundary)
         * - Add the character entering the window (right boundary)
         * - After each slide, check if the window is an anagram
         */
        while (windowEnd < text.length()) {
            // Remove outgoing character
            freqArr[text.charAt(windowStart) - 'a']--;
            windowStart++;

            // Add incoming character
            freqArr[text.charAt(windowEnd) - 'a']++;

            // Check if current window forms a permutation of pattern
            if (isAnagram(pattern, freqArr)) {
                return true;
            }

            windowEnd++;
        }

        // No permutation found
        return false;
    }

    /**
    * Checks whether the current window is an anagram of the pattern.
    *
    * Logic:
    * - Clone the window frequency array to avoid modifying the original state.
    * - For each character in the pattern:
    *     - If its frequency is zero in the window, it means either:
    *         1) The character is not present in the current window at all, OR
    *         2) The pattern contains this character more times than the window does.
    *       In both cases, the window cannot be an anagram.
    *     - Otherwise, decrement the frequency to account for one matched occurrence.
    * - If all characters of the pattern are successfully matched,
    *   the current window is an anagram.
    */
    private boolean isAnagram(String pattern, int[] freqArr) {
        // Clone to avoid mutating original frequency array
        freqArr = freqArr.clone();

        for (int i = 0; i < pattern.length(); i++) {
            int idx = pattern.charAt(i) - 'a';

            if (freqArr[idx] == 0) {
                return false;
            }

            freqArr[idx]--;
        }

        return true;
    }
}



//Better Approach

class Solution {
    public boolean checkInclusion(String pattern, String text) {
        if (pattern.length() > text.length()) {
            return false;
        }

        int windowStart = 0;
        int windowEnd = 0;
        int windowSize = pattern.length();

        /*
         * ------------------------------------------------------------
         * What does patternFreqMap represent?
         * ------------------------------------------------------------
         * patternFreqMap keeps track of how many MORE times
         * each character is still REQUIRED in the current window
         * to form a valid anagram.
         *
         * Initially:
         *   pattern = "aab"
         *   map = {a=2, b=1}
         *
         * Interpretation:
         * - a is required 2 more times
         * - b is required 1 more time
         */
        Map<Character, Integer> patternFreqMap = new HashMap<>();

        // Build frequency map from the pattern
        for (int i = 0; i < pattern.length(); i++) {
            char ch = pattern.charAt(i);
            patternFreqMap.put(ch, patternFreqMap.getOrDefault(ch, 0) + 1);
        }

        /*
         * Build the first window of size = pattern.length()
         * Reduce frequency when pattern characters appear in window.
         */
        while (windowEnd < windowSize) {
            char ch = text.charAt(windowEnd++);
            if (patternFreqMap.containsKey(ch)) {
                patternFreqMap.put(ch, patternFreqMap.get(ch) - 1);
            }
        }

        // If all frequencies are zero â†’ first window is an anagram
        if (isAnagram(patternFreqMap)) {
            return true;
        }

        while (windowEnd < text.length()) {
            /*
             * ------------------------------------------------------------
             * OUTGOING CHARACTER (leaving the window)
             * ------------------------------------------------------------
             * When a character leaves the window:
             * - If it belongs to the pattern, we INCREASE its count.
             *
             * Why?
             * - That character is no longer contributing to the current window.
             * - We now REQUIRE one more occurrence of it again to form an anagram.
             */
            char outgoing = text.charAt(windowStart);
            if (patternFreqMap.containsKey(outgoing)) {
                patternFreqMap.put(outgoing, patternFreqMap.get(outgoing) + 1);
            }

            windowStart++;

            /*
            * ------------------------------------------------------------
            * INCOMING CHARACTER (entering the window)
            * ------------------------------------------------------------
            * When a character enters the window:
            * - If it belongs to the pattern, we DECREASE its count.
            *
            * Why?
            * - This character helps satisfy the anagram requirement.
            */
            char incoming = text.charAt(windowEnd);
            if (patternFreqMap.containsKey(incoming)) {
                patternFreqMap.put(incoming, patternFreqMap.get(incoming) - 1);
            }

            if (isAnagram(patternFreqMap)) {
                return true;
            }

            windowEnd++;
        }

        return false;
    }

    /**
     * Checks whether the current window is an anagram.
     *
     * An anagram exists when:
     * - All character requirements are fully satisfied.
     * - i.e., all values in the frequency map are exactly zero.
     *
     * NOTE:
     * - Negative value means the window has MORE occurrences of this
     *   character than required by the pattern.
     * - Any positive value means some character is still missing.
     *
     * - Since the window size is FIXED and exactly equal to the pattern length:
     *
     *   If any CHARACTER OF THE PATTERN has a NEGATIVE frequency,
     *   it means the window contains MORE occurrences of that character
     *   than required by the pattern.
     *
     * - Because the total window size is fixed, this extra occurrence
     *   must be taking the place of some OTHER CHARACTER OF THE PATTERN.
     *
     * - Hence, at least one other character of the pattern
     *   will have a POSITIVE frequency (i.e., it is still missing).
     *
     * - Therefore, a valid anagram (permutation) exists
     *   ONLY when all pattern character frequencies are exactly zero.
    */
    private boolean isAnagram(Map<Character, Integer> patternFreqMap) {
        for (int freq : patternFreqMap.values()) {
            if (freq != 0) {
                return false;
            }
        }

        return true;
    }
}


//Optimal Approach 

class Solution {
    public boolean checkInclusion(String pattern, String text) {
        if (pattern.length() > text.length()) {
            return false;
        }

        /*
         * patternFreqArr:
         * Stores frequency of each character in the pattern.
         *
         * windowFreqArr:
         * Stores frequency of each character in the current window of text.
         */
        int[] patternFreqArr = new int[26];
        int[] windowFreqArr = new int[26];

        // Build frequency array for the pattern
        for (int i = 0; i < pattern.length(); i++) {
            patternFreqArr[pattern.charAt(i) - 'a']++;
        }

        int windowStart = 0;
        int windowEnd = 0;
        int windowSize = pattern.length();

        /*
         * Build the FIRST window of size = pattern length.
         * Count frequencies of characters in this initial window.
         */
        while (windowEnd < windowSize) {
            windowFreqArr[text.charAt(windowEnd) - 'a']++;
            windowEnd++;
        }

        // If first window's frequency matches the pattern, permutation found
        if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
            return true;
        }

        while (windowEnd < text.length()) {
            // Remove outgoing character
            windowFreqArr[text.charAt(windowStart++) - 'a']--;

            // Add incoming character
            windowFreqArr[text.charAt(windowEnd++) - 'a']++;

            // Check if current window is a permutation of the pattern
            if (areFrequenciesEqual(patternFreqArr, windowFreqArr)) {
                return true;
            }
        }

        // No permutation found in any window
        return false;
    }

    /**
     * Compares two frequency arrays.
     *
     * Logic:
     * - If frequencies of ALL characters ('a' to 'z') are equal,
     *   then the two strings are anagrams of each other.
     *
     */
    private boolean areFrequenciesEqual(int[] freqArr1, int[] freqArr2) {
        for (int i = 0; i < 26; i++) {
            if (freqArr1[i] != freqArr2[i]) {
                return false;
            }
        }

        return true;
    }
}
