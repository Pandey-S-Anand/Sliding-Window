//Bruteforce Approach

class Solution {
    public int[] maxSlidingWindow(int[] arr, int k) {
        // Total number of windows of size k
        int totalSizeKWindows = arr.length - k + 1;

        // Stores maximum element of each window
        int[] windowMaxima = new int[totalSizeKWindows];

        // Generate all subarrays
        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                // Current subarray size
                int subarraySize = end - start + 1;

                // Process only windows of exact size k
                if (subarraySize == k) {
                    // Find maximum element in the current window
                    int windowMax = findMaxInWindow(arr, start, end);
                    // Store the result for this window
                    windowMaxima[start] = windowMax;
                    // Move to the next window
                    break;
                }
            }
        }

        return windowMaxima;
    }

    private int findMaxInWindow(int[] arr, int start, int end) {
        int windowMax = Integer.MIN_VALUE;
        int low = start, high = end;

        while (low <= high) {
            windowMax = Math.max(windowMax, Math.max(arr[low++], arr[high--]));
        }

        return windowMax;
    }
}



//Better Approach

class Solution {
    public int[] maxSlidingWindow(int[] arr, int k) {
        // Total number of windows of size k
        int totalSizeKWindows = arr.length - k + 1;

        // Stores the maximum value for each window
        int[] windowMaxima = new int[totalSizeKWindows];

        /*
         * Max Heap stores index of the element
         *
         * The heap is ordered by the VALUE at those indices in descending order,
         * This ensures:
         * - The index at the top of the heap always corresponds
         *   to the maximum value in the current heap.
         *
         * Important:
         * - Indices are stored to identify and discard elements
         *   that fall out of the current window, i.e., elements
         *   that are part of previous windows.
         */
        Queue<Integer> maxHeap = new PriorityQueue<>((index1, index2) -> Integer.compare(arr[index2], arr[index1]));

        int windowStart = 0;
        int windowEnd = 0;

        /*
        * Build the first window of size k.
        * Insert indices of all elements of the first window into the heap.
        */
        while (windowEnd < k) {
            maxHeap.offer(windowEnd++);
        }

        // The index at the top of the heap corresponds to max value
        windowMaxima[windowStart] = arr[maxHeap.peek()];

        /*
        * Slide the window:
        * - Move windowStart forward
        * - Add the new element's index entering the window to the heap
        */
        while (windowEnd < arr.length) {
            windowStart++;

            // Add the index of the new element entering the window
            maxHeap.offer(windowEnd);

            // Get the maximum element for the current window
            windowMaxima[windowStart] = getMaxInWindow(maxHeap, windowStart, arr);

            windowEnd++;
        }

        return windowMaxima;
    }

    private int getMaxInWindow(Queue<Integer> maxHeap, int windowStart, int[] arr) {
        /*
         * The max heap always keeps the index whose corresponding
         * value in the array is maximum among all stored indices.
         *
         * However, the index at the top of the heap may not
         * necessarily belong to the current window.
         * It could belong to a previous window.
         *
         *
         * Therefore, before using the heap's top index,
         * we remove all indices that are less than windowStart,
         * because they fall outside the current window.
         *
         * Once all outdated indices are removed,
         * the index at the top of the heap is guaranteed
         * to correspond to the maximum element within the current window.
         *
         * ---------------------------------------------------------------
         * Example:
         *
         * nums = [9, 3, 1, 2, 5], k = 2
         *
         * ---------------------------------------------------------------
         * Window 1: indices [0 .. 1] → [9, 3]
         *
         * Heap contains indices:
         * 0 (value 9), 1 (value 3)
         *
         * - Top index = 0
         * - Value = arr[0] = 9
         * - Result[0] = 9
         *
         * ---------------------------------------------------------------
         * Window 2: indices [1 .. 2] → [3, 1]
         *
         * Add index 2
         *
         * Heap contains:
         * 0 (9), 1 (3), 2 (1)
         *
         * - Top index = 0
         * - But 0 < windowStart (1)
         * - So remove index 0
         *
         * New top index = 1
         * - Value = arr[1] = 3
         * - Result[1] = 3
         *
         * ---------------------------------------------------------------
         * Window 3: indices [2 .. 3] → [1, 2]
         *
         * Add index 3
         *
         * Heap contains:
         * 1 (3), 3 (2), 2 (1)
         *
         * - Top index = 1
         * - But 1 < windowStart (2)
         * - Remove index 1
         *
         * New top index = 3
         * - Value = arr[3] = 2
         * - Result[2] = 2
         *
         * ---------------------------------------------------------------
         * Window 4: indices [3 .. 4] → [2, 5]
         *
         * Add index 4
         *
         * Heap contains:
         * 4 (5), 3 (2), 2 (1)
         *
         * - Top index = 4
         * - It lies inside window
         * - Result[3] = 5
         *
         * ---------------------------------------------------------------
         * Key Takeaways:
         *
         * - The heap may store indices from older windows.
         * - This approach uses lazy removal for indices in the heap,
         *   indices are only removed when they impact the maximum value of the current window. 
         * - This guarantees correctness while avoiding unnecessary removals.
         */
        while (!maxHeap.isEmpty() && maxHeap.peek() < windowStart) {
            maxHeap.poll();
        }

        // The top index corresponds to the maximum in the current window
        return arr[maxHeap.peek()];
    }
}


//Optimal Approach

class Solution {
    /*
    * Intuition:
    *
    * The deque always contains only those elements that can still become
    * the maximum in some future window.
    *
    * We keep elements that are smaller but to the RIGHT of the current maximum
    * because they are potential candidates for the maximum when the current
    * maximum (at the front of the deque) slides out of the window.
    *
    * Why can we safely remove smaller elements to the LEFT?
    *
    * If an element A is smaller than a newer element B and A appears to the
    * left of B, then A can never be the maximum of any future window that
    * contains B.
    *
    * Reason:
    * - B is already larger than A, so B will always dominate A in any window
    *   containing both.
    * - B enters later and stays longer in future windows, while A will slide
    *   out earlier.
    * - Even if a newer element enters, it will either replace B (if larger)
    *   or B will remain the maximum.
    *
    * Therefore, for as long as the current maximum remains inside the window,
    * any smaller element to its left is useless. When the maximum slides out,
    * the deque already contains the next best candidates from the right.
    */
    public int[] maxSlidingWindow(int[] arr, int k) {
        int totalSizeKWindows = arr.length - k + 1;
        int[] windowMaxima = new int[totalSizeKWindows];

        Deque<Integer> decreasingQueue = new ArrayDeque<>();

        int windowStart = 0, windowEnd = 0;

        // Process the first window separately
        while (windowEnd < k) {
            while (!decreasingQueue.isEmpty() && (arr[windowEnd] > arr[decreasingQueue.peekLast()])) {
                decreasingQueue.pollLast();
            }

            decreasingQueue.offerLast(windowEnd++);
        }

        // The maximum for the first window
        windowMaxima[windowStart] = arr[decreasingQueue.peekFirst()];
        // Process the second window and all subsequent windows
        while (windowEnd < arr.length) {
            windowStart++;
            windowMaxima[windowStart] = findMaxInWindow(arr, windowStart, windowEnd, decreasingQueue);
            windowEnd++;
        }

        return windowMaxima;
    }

    private int findMaxInWindow(int[] arr, int windowStart, int windowEnd, Deque<Integer> decreasingQueue) {
        while (!decreasingQueue.isEmpty() && arr[windowEnd] > arr[decreasingQueue.peekLast()]) {
            decreasingQueue.pollLast();
        }

        decreasingQueue.offerLast(windowEnd);

        /*
        * Since the sliding window moves by 1 position at each step,
        * the maximum element, which is always at the front of the deque
        * (because the deque is maintained in decreasing order), is the
        * only element that can potentially fall out of the window.
        * 
        * As the left boundary of the window advances by 1 index, we need
        * to check if the element at the front of the deque is outside the
        * current window. If it is, we remove it to ensure the deque only
        * contains indices within the current window.
        * Ex: [5,3,4]
        */
        if (decreasingQueue.peekFirst() < windowStart) {
            decreasingQueue.pollFirst();
        }

        return arr[decreasingQueue.peekFirst()];
    }
}
